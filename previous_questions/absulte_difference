#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <climits>

using namespace std;

void DFS(int start, int end, int add_pop, vector<vector<int>>& graph, vector<int> &popularity, int n, vector<bool> visited, bool &valid, stack<int> &st) {
    if(start == end){
        //popularity[start-1] += add_pop;
        
        valid = true;
        return;
    }
    if(visited[start])
        return;
    
    visited[start] = true;
    st.push(start);
    while (!st.empty()) {
        cout<<"\n";
        int nd = st.top();
        st.pop();
        
        //cout << "pop : " << popularity[nd-1] << ", ";
        for (auto& edge : graph[nd]) {
            //cout << "edge in for : " << edge << endl;
            
            if(!visited[edge]){
                cout << edge << " -> ";
                visited[edge] = true;
                st.push(edge);
                popularity[edge-1] += add_pop;
                //cout << "addpop : " << edge << endl;
                DFS(edge, end, add_pop, graph, popularity, n, visited, valid, st);
                //cout << "addpop : " << edge << endl;
                //st.pop();
                if(valid != true){
                    cout << "curedge : " << edge << endl;
                    popularity[edge-1] -= add_pop;
                }
                //popularity[edge-1] -= add_pop;
                
                //
            }
            if(valid){
                cout << edge << " ytfyug ";
                while(!st.empty()) st.pop();
                popularity[nd-1] += add_pop;
                break;
            }
        }
      //  if(!valid)
       // popularity[nd-1] += add_pop;
        //st.pop();
    }
    visited[start] = false;
    //popularity[start-1] -= add_pop;
}

int absolute_difference(int N, vector<int> &popularity, vector<vector<int>> &uv, int Q, vector<vector<int>> &abx) {
    vector<vector<int>> graph(N+1);
    for (int i=0; i<uv.size(); i++){
        int u = uv[i][0];
        int v = uv[i][1];
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    for(int i=0; i<Q; i++){
        int start = abx[i][0];
        int end = abx[i][1];
        int add_pop = abx[i][2];
        vector<bool> visited(N+1, false);
        popularity[start-1] += add_pop;
        bool valid = false;
        stack<int> st;
        DFS(start, end, add_pop, graph, popularity, N, visited, valid, st);
        cout << endl;
    }
    int jack=0, bob=0;
    for(int i=0; i<N; i++){
        cout << popularity[i] << " ";
        if(i%2 == 0){
            bob += popularity[i]; 
        } else {
            jack += popularity[i];
        }
    }
    cout << endl;
    return abs(jack-bob);
}

int main() {
    int N=6;
    vector<vector<int>> uv={{1,2}, {1,3}, {2,6}, {3,4}, {3,5}};
    vector<int> popularity = {1, 2, 3, 4, 4, 2};
    int Q = 3;
    vector<vector<int>> abx = {{5,4,1}, {1,6,2}, {2,3,3}};
    /**/

    cout << absolute_difference(N, popularity, uv, Q, abx) << endl;

    return 0;
}

=============================

#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <climits>

using namespace std;

// Helper function to get path from start to end using DFS
bool find_path(int start, int end, vector<vector<int>> &graph, vector<bool> &visited, vector<int> &path) {
    visited[start] = true;
    path.push_back(start);

    if (start == end) return true;

    for (int neighbor : graph[start]) {
        if (!visited[neighbor]) {
            if (find_path(neighbor, end, graph, visited, path))
                return true;
        }
    }

    path.pop_back();
    return false;
}

int absolute_difference(int N, vector<int> &popularity, vector<vector<int>> &uv, int Q, vector<vector<int>> &abx) {
    vector<vector<int>> graph(N + 1);

    // Building the graph
    for (const auto &edge : uv) {
        int u = edge[0], v = edge[1];
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    // Process each query
    for (int i = 0; i < Q; ++i) {
        int start = abx[i][0], end = abx[i][1], add_pop = abx[i][2];
        vector<bool> visited(N + 1, false);
        vector<int> path;

        // Find path from start to end
        if (find_path(start, end, graph, visited, path)) {
            for (int node : path) {
                popularity[node - 1] += add_pop;
            }
        }
    }

    // Calculate difference between Jack and Bob
    int jack = 0, bob = 0;
    for (int i = 0; i < N; ++i) {
        if (i % 2 == 0)
            bob += popularity[i];
        else
            jack += popularity[i];
    }

    return abs(jack - bob);
}

int main() {
    int N = 6;
    vector<vector<int>> uv = {{1, 2}, {1, 3}, {2, 6}, {3, 4}, {3, 5}};
    vector<int> popularity = {1, 2, 3, 4, 4, 2};
    int Q = 3;
    vector<vector<int>> abx = {{5, 4, 1}, {1, 6, 2}, {2, 3, 3}};

    cout << absolute_difference(N, popularity, uv, Q, abx) << endl;
    return 0;
}

============================
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

class Tree {
public:
    int N, LOG;
    vector<vector<int>> graph;
    vector<int> depth;
    vector<vector<int>> parent;
    vector<int> popularity;
    vector<int> diff;

    Tree(int n, vector<int>& pop) : N(n), popularity(pop) {
        graph.resize(N + 1);
        depth.resize(N + 1);
        LOG = 0;
        while ((1 << LOG) <= N) LOG++;
        parent.assign(N + 1, vector<int>(LOG));
        diff.assign(N + 1, 0);
    }

    void addEdge(int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    void dfs(int u, int p) {
        parent[u][0] = p;
        for (int i = 1; i < LOG; ++i) {
            parent[u][i] = parent[parent[u][i - 1]][i - 1];
        }

        for (int v : graph[u]) {
            if (v != p) {
                depth[v] = depth[u] + 1;
                dfs(v, u);
            }
        }
    }

    int lca(int u, int v) {
        if (depth[u] < depth[v]) swap(u, v);
        int diff_depth = depth[u] - depth[v];

        for (int i = LOG - 1; i >= 0; --i) {
            if ((diff_depth >> i) & 1) {
                u = parent[u][i];
            }
        }

        if (u == v) return u;

        for (int i = LOG - 1; i >= 0; --i) {
            if (parent[u][i] != parent[v][i]) {
                u = parent[u][i];
                v = parent[v][i];
            }
        }
        return parent[u][0];
    }

    // Propagate the diff array down the tree to finalize popularity
    void propagate(int u, int p) {
        for (int v : graph[u]) {
            if (v != p) {
                diff[v] += diff[u];
                propagate(v, u);
            }
        }
        popularity[u - 1] += diff[u]; // Apply final popularity change
    }
};

int absolute_difference(int N, vector<int> &popularity, vector<vector<int>> &uv, int Q, vector<vector<int>> &abx) {
    Tree tree(N, popularity);

    // Build graph
    for (auto &edge : uv) {
        tree.addEdge(edge[0], edge[1]);
    }

    // Preprocessing for LCA
    tree.depth[1] = 0;
    tree.dfs(1, 1);

    // Apply difference array for queries
    for (int i = 0; i < Q; ++i) {
        int a = abx[i][0];
        int b = abx[i][1];
        int x = abx[i][2];

        int ancestor = tree.lca(a, b);
        tree.diff[a] += x;
        tree.diff[b] += x;
        tree.diff[ancestor] -= x;
        if (ancestor != 1) { // if ancestor not root, subtract from its parent as well
            tree.diff[tree.parent[ancestor][0]] -= x;
        }
    }

    // Propagate changes from root
    tree.propagate(1, -1);

    // Calculate final difference between Jack and Bob
    int jack = 0, bob = 0;
    for (int i = 0; i < N; ++i) {
        if (i % 2 == 0)
            bob += tree.popularity[i];
        else
            jack += tree.popularity[i];
    }

    return abs(jack - bob);
}

int main() {
    int N = 6;
    vector<vector<int>> uv = {{1, 2}, {1, 3}, {2, 6}, {3, 4}, {3, 5}};
    vector<int> popularity = {1, 2, 3, 4, 4, 2};
    int Q = 3;
    vector<vector<int>> abx = {{5, 4, 1}, {1, 6, 2}, {2, 3, 3}};

    cout << absolute_difference(N, popularity, uv, Q, abx) << endl;
    return 0;
}


