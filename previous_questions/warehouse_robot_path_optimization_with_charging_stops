#include <bits/stdc++.h>
using namespace std;

struct Point {
    int pos;
    bool isTask;
    bool visited;
};

int N, M, B;
vector<Point> points;
int minDistance = INT_MAX;

void backtrack(int currentPos, int batteryLeft, int tasksLeft, int distTravelled) {
    if (tasksLeft == 0) {
        int distToStart = abs(currentPos - 0);
        if (batteryLeft >= distToStart) {
            minDistance = min(minDistance, distTravelled + distToStart);
        } else {
            for (int j = 0; j < points.size(); j++) {
                if (!points[j].isTask) {
                    int distToCharge = abs(points[j].pos - currentPos);
                    if (batteryLeft >= distToCharge) {
                        int distChargeToStart = abs(points[j].pos - 0);
                        if (B >= distChargeToStart) {
                            minDistance = min(minDistance, distTravelled + distToCharge + distChargeToStart);
                        }
                    }
                }
            }
        }
        return;
    }

    if (distTravelled >= minDistance) return;

    for (int i = 0; i < points.size(); i++) {
        if (points[i].isTask && !points[i].visited) {
            int travelDist = abs(points[i].pos - currentPos);

            if (batteryLeft >= travelDist) {
                points[i].visited = true;
                backtrack(points[i].pos, batteryLeft - travelDist, tasksLeft - 1, distTravelled + travelDist);
                points[i].visited = false;
            } else {
                for (int j = 0; j < points.size(); j++) {
                    if (!points[j].isTask) {
                        int distToCharge = abs(points[j].pos - currentPos);
                        if (batteryLeft >= distToCharge) {
                            int distChargeToTask = abs(points[i].pos - points[j].pos);
                            if (B >= distChargeToTask) {
                                points[i].visited = true;
                                backtrack(points[i].pos, B - distChargeToTask, tasksLeft - 1,
                                          distTravelled + distToCharge + distChargeToTask);
                                points[i].visited = false;
                            }
                        }
                    }
                }
            }
        }
    }
}

int main() {
    cout << "Enter number of tasks, number of charging stations, battery capacity: ";
    cin >> N >> M >> B;

    points.clear();

    cout << "Enter task positions: ";
    for (int i = 0; i < N; i++) {
        int pos; cin >> pos;
        points.push_back({pos, true, false});
    }

    cout << "Enter charging station positions: ";
    for (int i = 0; i < M; i++) {
        int pos; cin >> pos;
        points.push_back({pos, false, false});
    }

    backtrack(0, B, N, 0);

    if (minDistance == INT_MAX) {
        cout << "No feasible path found." << endl;
    } else {
        cout << "Minimum distance traveled: " << minDistance << endl;
    }

    return 0;
}


==============================================


#include <bits/stdc++.h>
using namespace std;

int N, M, B;
vector<int> tasks, stations;
vector<bool> visited;
int minDistance = INT_MAX;

void backtrack(int currentPos, int batteryLeft, int tasksLeft, int distTravelled) {
    if (tasksLeft == 0) {
        int distToStart = abs(currentPos - 0);
        if (batteryLeft >= distToStart) {
            minDistance = min(minDistance, distTravelled + distToStart);
        } else {
            for (int j = 0; j < stations.size(); j++) {
                int distToCharge = abs(stations[j] - currentPos);
                if (batteryLeft >= distToCharge) {
                    int distChargeToStart = abs(stations[j] - 0);
                    if (B >= distChargeToStart) {
                        minDistance = min(minDistance, distTravelled + distToCharge + distChargeToStart);
                    }
                }
            }
        }
        return;
    }

    if (distTravelled >= minDistance) return;

    for (int i = 0; i < tasks.size(); i++) {
        if (!visited[i]) {
            int travelDist = abs(tasks[i] - currentPos);

            if (batteryLeft >= travelDist) {
                visited[i] = true;
                backtrack(tasks[i], batteryLeft - travelDist, tasksLeft - 1, distTravelled + travelDist);
                visited[i] = false;
            } else {
                for (int j = 0; j < stations.size(); j++) {
                    int distToCharge = abs(stations[j] - currentPos);
                    if (batteryLeft >= distToCharge) {
                        int distChargeToTask = abs(tasks[i] - stations[j]);
                        if (B >= distChargeToTask) {
                            visited[i] = true;
                            backtrack(tasks[i], B - distChargeToTask, tasksLeft - 1,
                                          distTravelled + distToCharge + distChargeToTask);
                            visited[i] = false;
                        }
                    }
                }
            }
        }
    }
}

int main() {
    cin >> N >> M >> B;
    visited.resize(N);
    for (int i = 0; i < N; i++) {
        int pos; cin >> pos;
        tasks.push_back(pos);
        visited[i] = false;
    }

    for (int i = 0; i < M; i++) {
        int pos; cin >> pos;
        stations.push_back(pos);
    }

    backtrack(0, B, N, 0);

    if (minDistance == INT_MAX) {
        cout << "-1" << endl;
    } else {
        cout << "Minimum distance traveled: " << minDistance << endl;
    }

    return 0;
}
