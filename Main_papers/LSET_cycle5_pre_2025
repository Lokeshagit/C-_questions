Question1: Delivery route capacity Management:

#include <bits/stdc++.h>
using namespace std;

int find_maxpackages(int n, vector<vector<int>>& deliveries){
    map<int, int> events;
    
    for(int i=0; i<n; i++){
        events[deliveries[1][i]] += deliveries[0][i];
        events[deliveries[2][i]] -= deliveries[0][i];
    }
    int current=0, maxPackages=0;
    for(auto &[loc, change]: events){
        current += change;
        maxPackages = max(maxPackages, current);
    }
    return maxPackages;
}

int main()
{
    int n;
    cin >> n;
    vector<vector<int>> deliveries(3, vector<int>(n));
    for(int i=0; i<3; i++){
        for(int j=0; j<n; j++){
            cin >> deliveries[i][j];
        }
    }
    
    int ans = find_maxpackages(n, deliveries);
    cout << ans << endl;

    return 0;
}

Input: 3
5 3 2
1 2 4
8 6 9

Output:
10

=====================================

Question2 : Spell Fragmentation decoder:


#include <bits/stdc++.h>
using namespace std;

int maxWordCount(const string &s, const vector<string> &dict) {
    int n = s.size();
    vector<int> dp(n + 1, -1);
    dp[n] = 0;

    for (int i = n - 1; i >= 0; --i) {
        for (const string &word : dict) {
            int len = word.size();
            if (i + len <= n && s.substr(i, len) == word && dp[i + len] != -1) {
                dp[i] = max(dp[i], 1 + dp[i + len]);
            }
        }
    }

    return dp[0] == -1 ? 0 : dp[0];
}

int main() {
    string s;
    cin >> s;

    int n;
    cin >> n;

    vector<string> dict(n);
    for (int i = 0; i < n; ++i)
        cin >> dict[i];

    cout << maxWordCount(s, dict) << endl;

    return 0;
}

Input:
aaaaa
2
a
aa

Output:
5

=====================================

Question3: Count_kings

#include <bits/stdc++.h>
using namespace std;
using pii = pair<int,int>;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N; cin >> N;
    vector<int> royalty(N+1);
    for(int i=1; i<=N; i++) cin >> royalty[i];
    vector<int> parent(N+1);
    for(int i=2; i<=N; i++) cin >> parent[i];
    vector<int> cap(N+1);
    for(int i=2; i<=N; i++) cin >> cap[i];
    int q; cin >> q;
    vector<long long> queries(q);
    long long maxQ=0;
    for(int i=0; i<q; i++) {
        cin >> queries[i];
        maxQ = max(maxQ, queries[i]);
    }
    

    vector<vector<pii>> arrival(maxQ+2);
    for(int i=1; i<=N; i++){
        arrival[0].push_back({i, i});
    }
	
	vector<priority_queue<pii>> pq(N+1);
    vector<int> in_active(N+1, 0);
    vector<int> reached_count(maxQ+1);
    long long total_reached=0;
	vector<int> cur_active, next_active;
    for(long long day=0; day<=maxQ; day++){
        for(auto [node, king]: arrival[day]){
            if(node == 1){
                reached_count[day]++;
                total_reached++;
            } else {
                pq[node].push({royalty[king], king});
                if(!in_active[node]){
                    in_active[node] = 1;
                    cur_active.push_back(node);
                }
            }
        }
        if(total_reached == N) break;
        if(cur_active.empty()) continue;
        
		next_active.clear();
        for(auto node:cur_active){
            in_active[node] = 0;
            if(node == 1) continue;
            int c = cap[node];
            while(c-- && !pq[node].empty()){
                int king = pq[node].top().second;
                pq[node].pop();
                int p = parent[node];
                if(p == 1){
                    reached_count[day+1]++;
                    total_reached++;
                } else {
                    arrival[day+1].push_back({p, king});
                }
            }
            if(!pq[node].empty()){
                next_active.push_back(node);
                in_active[node]=1;
            }
        }
        cur_active.swap(next_active);
    }
    vector<long long> ans(maxQ+2, 0);
    long long count=0;
    for(long long d=0; d<= maxQ; d++){
        count += reached_count[d];
        ans[d] = count;
    }
    vector<long long> res(q);
    for(int i=0; i<q; i++){
        res[i] = ans[queries[i]];
    }
    for(auto x:res) {
        cout << x << " ";
    }
    return 0;
}

---------------

Input:
N=4
royalty = 4 1 3 2
edges = 1 2 2
capacity = 1 1 1
q = 4
queries = 2 1 5 3

output : 3 2 4 4
