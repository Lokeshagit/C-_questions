Question1: 

Code Understanding
Let us consider the below grid where n = 5, considering row and column are numbered from 0 to n-1. Each cell has a score value ranged from 0 to 106.

There will be a starting point cell and It is allowed to jump in all the 8 directions from that point with below conditions

a jump to next cell is possible in all the 8 directions (up, right, down, left, upper left, upper right, lower right, lower left)
the jump should follow in a specific order where it start from upper left, up, upper right, right, lower right, down, lower left, left
If a jumped cell has no score, it shouldn't be accounted
The given code calculates the total score after 1 jump of all possible directions from the starting point.

But the new rule is not have the 2nd jump with below conditions

No score calculated on 1st jump
If a cell has score = 0, there is no possible 2nd jump from that cell
if a cell is already jumped on the 1st attempt, no jump possible on that cell on 2nd jump
Illustration
From the rules, below grid represent that

Cell (2,2) is the starting point.

The green marked cells are possible regions on 1st jump

The blue marked cells are possible region on 2nd jump

The red marked cells are no jump area as cell (1, 1) and (2, 1) have score = 0 in 1st jump

1	2	3	4	5
16	0	3	8	6
15	0	5	6	7
14	3	6	7	8
13	12	11	10	9
Such a way the score comes as

(2+3+4) + (3+4+5+6+7) + (6+7+8) + (7+8+9+10+11) + (10+11+12) + (11+12+13+14+15) = 198

Constraints
5 <= n <= 100

0 <= score <= 106

Input Format
Line 1 contains a value that represents n

line 2 contains 2 values that represent the start point coordinate of a cell

Next n line contain the grid value where each line has n no. of values

5

2 2

1 2 3 4 5

16 0 3 8 6

15 0 5 6 7

14 3 6 7 8

13 12 11 10 9

Output Format
Print the sum of 2nd jump scores from all the directions

198

----------------

int hop2jumps(int sx, int sy)
    static int dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};
    static int dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};
 
    int sum = 0;
    vector<vector<bool>> vis(n, vector<bool>(n, false);
 
    for (int i = 0; i < 8; i++) {
        int nx = sx+dx[i];
        int ny = sy+dy[i];
 
        if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
 
        vis[nx][ny] = true;
    }
 
    for (int i = 0; i < 8; i++) {
        int nx = sx+dx[i];
        int ny = sy+dy[i];
 
        if (nx < 0 || nx >= n || ny < 0 || ny >= n || mapped[nx][ny]==0) continue;
 
        for (int j = 0; j < 8; j++) {
            int nx1 = nx+dx[j];
            int ny1 = ny+dy[j];
 
            if (nx1 < 0 || nx1 >= n || ny1 < 0 || ny1 >= n || vis[nx1][ny1]) continue;
            sum += mapped[nx1][ny1];
    }
    return sum;
}

===================================

Question2: 

A farmer has a land that represent in n x n grid. Each small region (a cell) has a height value.

The farmer thinking to buy a robot to take care his land. The robot comes with a constraints that

it can manage only the region that has the height difference not more than d value between cells
it can traverse between cells only in 4 directions (up, left, right, down)
In case the region (no. of cells) are not more than (k), the farmer takes care of those region in order to minimize the cost of buying robot.

Help the farmer to buy minimal no. of robots and identify how many regions the farmer has to take care.

Illustration
Below grid represent with n = 5 where each cell contains a value (H)

Given n =5, d = 3, k = 2

The green marked region are covered by one robot where the height difference between cells are not more than d.

The yellow marked region is another zone where cells with height difference not more than d and this region manages by another robot.

The cell (4, 4) and (4, 5) are manage by the farmer as this zone has 2 cells which is not more than k.

From this, the farmer needs 2 robots to buy and he manages 2 cells

2	3	4	2	5
4	2	1	5	2
1	3	2	4	5
6	7	6	8	9
10	11	7	6	8
Constraints
5 <= n <= 10000

0 <= H, d, k <= 109

Input Format
Line 1 has 3 values and it represents n, d and k respectively

The next n line have n values in each line that represent the height value of each cell in the nxn grid

5 3 2
2 3 4 2 5
4 2 1 5 2
1 3 2 4 5
6 7 6 8 9
10 11 7 6 8
Output Format
First value represent the no. of robots to buy, 2nd value represents the no. of regions that farmer takes care

2 2


----------------------

#include <bits/stdc++.h>
using namespace std;

int solve(int r, int c, int n, int hieght, vector<vector<int>>& grid, vector<vector<int>>& vis){
    queue<pair<int, pair<int, int>>> q;
    q.push({grid[r][c], {r, c}});
    vis[r][c] = 1;
    int cnt=0;
    int dr[] = {0, 0, 1, -1};
    int dc[] = {1, -1, 0, 0};
    while(!q.empty()){
        int h=q.front().first;
        int x=q.front().second.first;
        int y=q.front().second.second;
        q.pop();
        cnt++;
        for(int d=0; d<4; d++){
            int nr=x+dr[d];
            int nc=y+dc[d];
            if(nr<0 || nr>=n || nc<0 || nc>=n || abs(grid[nr][nc]-h)>hieght || vis[nr][nc]) continue;
            q.push({grid[nr][nc], {nr, nc}});
            vis[nr][nc]=1;
        }
    }
    return cnt;
}

int main()
{
    int n, d, k;
    cin >> n >> d >> k;
    
    vector<vector<int>> grid(n, vector<int>(n)), vis(n, vector<int>(n, 0));
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            cin >> grid[i][j];
        }
    }
    cout << "grid " << n << " " << d << " " << k << endl;
    int farmer=0, robot=0;
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            if(!vis[i][j]){
                int count = solve(i, j, n, d, grid, vis);
                if(count <= k){
                    farmer+=count;
                } else {
                    robot++;
                }
            }
        }
    }
    cout << farmer << " : " << robot << endl;
    return 0;
}

========================================

Question3 :

There is a warp gate that allows to enter a guest through it. There is no time represents in hours, minutes and seconds rather the time for a day considered as 1/140000t ie) the gate operates a whole day that allows a maximum of 140000 guests.

The booking system follows a reservation that permits the guest to reach the gate at a specific time (reservation time). However, the guests are either late than their reservation time or earlier to it.

The system follows below rules

The maximum waiting room capacity is 140000
If a guest is early to their reservation time, they should wait in the waiting room. They can enter the gate only if 1 in the queue
If a guest is late to their reservation time, they should wait in the waiting room. They can enter the gate only if 1 in the queue
waiting time of a guest is calculated in a way that difference between the current time and the arrival time of the guest
Find the maximum time where the last guest enters the gate and the maximum wait time of the guests.

Constraints
6 <= n <= 106

1 <= Arrival Time, Reserved Time <= 140000

Input Format
Line 1 represent the n value

Next n lines contain n guest arrival and reserved time in each line 

It is guaranteed that the arrival time is given in ascending order and if more than 1 guest has same arrival time, it is ascending arranged based on reserved time

6

1 3
2 1
2 2
5 4
5 5
5 6

Output Format
Time at which the last guest enters the gate and the maximum wait time of the guests

7 2

----------------------------

#include <bits/stdc++.h>
using namespace std;
 
#define MAXN (int)1e5
 
int N;
int arrival[MAXN], reserved[MAXN];
int ans_last_time, max_wait_time;
 
void InputData() {
    cin >> N;
    for (int i = 0; i < N; i++) {
        cin >> arrival[i] >> reserved[i];
    }
}
 
void solve() {
    map<int, int> order;
    for (int i = 0; i < N; i++)
        if (arrival[i] == reserved[i])
            order[arrival[i]] = i;
 
    int i = 0, done = 0, t = 0, maxWait = 0;
    vector<bool> vis(N, false);
    auto itr = order.begin();
    while (done < N) {
        if (itr != order.end() and itr->first == t) {
            vis[order[t]] = true;
            done++;
            itr++;
        }
        else if (arrival[i] <= t and !vis[i]) {
            done++;
            maxWait = max(maxWait, t - arrival[i]);
            vis[i] = true;
        }
        else if (vis[i]) {
            i++;
            continue;
        }
        t++;
    }
    ans_last_time = t-1;
    max_wait_time = maxWait;
}
 
int main()
{
    InputData();
    solve();
    cout << ans_last_time << " " << max_wait_time;
    return 0;
}

===============================================
