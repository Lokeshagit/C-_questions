Question1 : Maximum adjacent Increasing segment:

class Solution {
 public:I
  int maxIncreasingSubarrays(vector<int>& nums) {
    int ans = 0;
    int w1 = 1;
    int w2 = 0;

    for (int i = 1; i < nums.size(); ++i) {
      if (nums[i] > nums[i - 1]) {
        ++w1;
      } else {
        w2 = w1;
        w1 = 1;
      }
      ans = max(ans, max(w1, w2) / 2);
      ans = max(ans, min(w2, w1));
    }

    return ans;
  }
};

-------------------------

int maxIncreasingSubarrays(vector<int>& nums) {
    int n = nums.size();
    int curr_len = 1,max_len=1,maxi=1;
    int mini = 1e9;
    int prev_len = curr_len;
    int l =0,r=1;
    while(r<n)
    {
        if(nums[r] <= nums[r-1])
        {
            prev_len = curr_len;
            curr_len = r-l;
            mini = min(prev_len,curr_len);
            max_len = max(max_len,curr_len);
            maxi = max(maxi,mini);
            l=r;
        }
        r++;
    }
    if(r==n)
    {
        prev_len = curr_len;
        curr_len = r-l;
        mini = min(prev_len,curr_len);
        max_len = max(max_len,curr_len);
        maxi = max(maxi,mini);
    }
    return max(max_len/2,maxi);
   
}


Input : [2,5,7,8,9,2,3,4,3,1]
Output : 3

=====================================

Question2: Delivery route capacity Management:

#include <bits/stdc++.h>
using namespace std;

int find_maxpackages(int n, vector<vector<int>>& deliveries){
    map<int, int> events;
    
    for(int i=0; i<n; i++){
        events[deliveries[1][i]] += deliveries[0][i];
        events[deliveries[2][i]] -= deliveries[0][i];
    }
    int current=0, maxPackages=0;
    for(auto &[loc, change]: events){
        current += change;
        maxPackages = max(maxPackages, current);
    }
    return maxPackages;
}

int main()
{
    int n;
    cin >> n;
    vector<vector<int>> deliveries(3, vector<int>(n));
    for(int i=0; i<3; i++){
        for(int j=0; j<n; j++){
            cin >> deliveries[i][j];
        }
    }
    
    int ans = find_maxpackages(n, deliveries);
    cout << ans << endl;

    return 0;
}

Input: 3
5 3 2
1 2 4
8 6 9

Output:
10

===========================================

Question3 : Island path connectivity:

#include <bits/stdc++.h>
using namespace std;
bool is_possible(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& visited, int rows, int columns){
    vector<vector<int>> vis;
    vis = visited;
    queue<pair<int, int>> q;
    q.push({r, c});
    vis[r][c] = 1;
    int dr[] = {0, 0, 1, -1};
    int dc[] = {1, -1, 0, 0};
    while(!q.empty()){
        pair<int, int> p = q.front(); q.pop();
        if(p.first == rows-1) return true;
        for(int d=0; d<4; d++){
            int nr = p.first + dr[d];
            int nc = p.second + dc[d];
            if(nr<0 || nr>=rows || nc<0 || nc>=columns || grid[nr][nc] == 1 || vis[nr][nc] == 1) continue;
            if(nr == rows-1) return true;
            q.push({nr,nc});
            vis[nr][nc] = 1;
        }
    }
    return false;
}

int main()
{
    int r, c, n;
    cin >> r >> c >> n;
    vector<vector<int>> floodSequence(n, vector<int>(2));
    for(int i=0; i<n; i++) {
        cin >> floodSequence[i][0] >> floodSequence[i][1];
    }
    vector<vector<int>> grid(r, vector<int>(c, 0)), visited(r, vector<int>(c, 0));
    int ans=r-1;

    for(int i=0; i<n; i++){
        grid[floodSequence[i][0]-1][floodSequence[i][1]-1] = 1;
        visited[floodSequence[i][0]-1][floodSequence[i][1]-1] = 1;
        if(i<r-1) continue;
        for(int x=0; x<c; x++){
            if(grid[0][x] == 0){
                if(is_possible(0, x, grid, visited, r, c)){
                    ans++;
                    break;
                }
            }
        }
    }
    
    cout << ans << endl;

    return 0;
}


---------------------------------------

#include <bits/stdc++.h>
using namespace std;
bool solve(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& visited, int rows, int columns){
    vector<vector<int>> vis;
    vis = visited;
    queue<pair<int, int>> q;
    q.push({r, c});
    vis[r][c] = 1;
    int dr[] = {0, 0, 1, -1};
    int dc[] = {1, -1, 0, 0};
    while(!q.empty()){
        pair<int, int> p = q.front(); q.pop();
        if(p.first == rows-1) return true;
        for(int d=0; d<4; d++){
            int nr = p.first + dr[d];
            int nc = p.second + dc[d];
            if(nr<0 || nr>=rows || nc<0 || nc>=columns || grid[nr][nc] == 1 || vis[nr][nc] == 1) continue;
            if(nr == rows-1) return true;
            q.push({nr,nc});
            vis[nr][nc] = 1;
        }
    }
    return false;
}

bool is_possible(int mid, int r, int c, vector<vector<int>>& floodSequence){
    vector<vector<int>> grid(r, vector<int>(c, 0)), visited(r, vector<int>(c, 0));
    for(int i=0; i<mid; i++){
        grid[floodSequence[i][0]-1][floodSequence[i][1]-1] = 1;
        visited[floodSequence[i][0]-1][floodSequence[i][1]-1] = 1;
    }
    for(int x=0; x<c; x++){
        if(grid[0][x] == 0){
            if(solve(0, x, grid, visited, r, c)) return true;
        }
    }
    return false;
}

int main()
{
    int r, c, n;
    cin >> r >> c >> n;
    vector<vector<int>> floodSequence(n, vector<int>(2));
    for(int i=0; i<n; i++) {
        cin >> floodSequence[i][0] >> floodSequence[i][1];
    }
    
    int low=0, high=n-1, ans=0;
    while(low<=high){
        int mid = low+(high-low)/2;
        if(is_possible(mid, r, c, floodSequence)){
            ans = mid;
            low = mid+1;
        } else {
            high = mid-1;
        }
    }
    cout << ans << endl;

    return 0;
}


Input: 
3 3 9
1 2
2 1
3 3
2 2
1 1
1 3
2 3
3 1
3 2
