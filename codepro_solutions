Question1: Product Display:

#include <iostream>
using namespace std;
#define MAXN (1000)

int N;
int ID[MAXN + 10];

int CalLargestBlock(int id_ignore){
	int max_block_size = 1;
	int cur_size = 1;
	int prev=ID[0];
	for (int i = 1; i < N; i++){
		if(ID[i]==id_ignore) continue;
		if (ID[i] == prev) cur_size++;
		else cur_size = 1;
		prev=ID[i];
		if (max_block_size < cur_size) {
			max_block_size = cur_size;
		}
	}
	return max_block_size;
}

int Solve(){
	int sol = (int)1e7, max_cnt = 0;
	for (int i = 0; i < N; i++){
		int ret = CalLargestBlock(ID[i]);
		if ((max_cnt < ret) || ((max_cnt == ret) && (sol < ID[i]))) {
			max_cnt = ret;
			sol = ID[i];
		}
	}
	return sol;
}

void InputData(){
	cin >> N;
	for (int i = 0; i < N; i++){
		cin >> ID[i];
	}
}

int main(){
	int ans;
	InputData();

	ans = Solve();

	cout << ans << "\n";
	return 0;
}

Input:
10
2 3 3 7 2 7 2 7 3 3 


Output:
2

===============================

Question2: Balancing

#include<bits/stdc++.h>
using namespace std;
int main(){
	int n; cin>>n; 
	vector<vector<int>>v(n,vector<int>(n,0));
	vector<int>row(n,0),col(n,0);
	int total =0;
	for(int i=0; i<n; i++){
		for(int j=0; j<n; j++){
			cin>>v[i][j];
			total += v[i][j];
			row[i]+=v[i][j];
			col[j]+=v[i][j];
		}
	}
	int maxi=max(*max_element(row.begin(),row.end()),*max_element(col.begin(),col.end()));
	int ans=0;
	ans = (maxi*n) - total;
	cout<<ans<<endl;
}


Input:
3
1 2 3
4 2 3
3 2 1


Output:
6

===============================

Question3: Setting the Exploration Route

#include <bits/stdc++.h>
using namespace std;
#define MAX_RC 100
int R, C;
char grid[MAX_RC][MAX_RC+1];

vector<vector<int>> bfs(pair<int, int> start){
    vector<vector<int>> dist(R, vector<int>(C, INT_MAX));
    queue<pair<int, int>> q;
    dist[start.first][start.second] = 0;
    q.push(start);
    int dr[] = {0, 0, 1, -1};
    int dc[] = {1, -1, 0, 0};
    while(!q.empty()){
        int r=q.front().first;
        int c=q.front().second;
        q.pop();
        for(int d=0; d<4; d++){
            int nr = r + dr[d];
            int nc = c + dc[d];
            if(nr<0 || nr>=R || nc<0 || nc>=C || grid[nr][nc] == '*' || dist[nr][nc] != INT_MAX) continue;
            dist[nr][nc] = dist[r][c]+1;
            q.push({nr, nc});
        }
    }
    return dist;
}

--------------------------------

int findTSP(vector<vector<int>>& dist, int n){
    int distance=INT_MAX;
    vector<int> point;
    for(int i=1; i<n; i++) point.push_back(i);
    do{
        int k=0;
        int d=0;
        for(int i=0; i<n-1;i++){
            d += dist[k][point[i]];
            k=point[i];
        }
        d += dist[k][0];
        distance = min(distance, d);
    } while(next_permutation(point.begin(), point.end()));
    
    return distance;
}

------------------------------------

int findTSP(const vector<vector<int>> &dist, int n) {
    int maxMask = 1 << n;
    vector<vector<int>> dp(maxMask, vector<int>(n, INT_MAX));
    dp[1][0] = 0;

    for (int mask = 0; mask < maxMask; mask++) {
        for (int j = 0; j < n; j++) {
            if ((mask & (1 << j)) == 0) continue;
            if (dp[mask][j] == INT_MAX) continue;
            for (int k = 0; k < n; k++) {
                if ((mask & (1 << k)) != 0) continue;
                int nextMask = mask | (1 << k);
                dp[nextMask][k] = min(dp[nextMask][k], dp[mask][j] + dist[j][k]);
            }
        }
    }

    int res = INT_MAX;
    for (int i = 0; i < n; i++) {
        res = min(res, dp[maxMask - 1][i] + dist[i][0]);
    }
    return res;
}

---------------------------------------------------

int main()
{
    cin >> R >> C;
    unordered_map<char, pair<int, int>> digit_map;
    for(int i=0; i<R; i++){
        for(int j=0; j<C; j++){
            char ch;
            cin >> ch;
            grid[i][j] = ch;
            if(ch == 'S' || (ch >= '0' && ch <= '9')){
                digit_map[ch] = {i, j};
            }
        }
    }
    int n=digit_map.size();
    vector<pair<int, int>> order(n);
    order[0] = digit_map['S'];
    for(int i=1; i<n; i++){
        order[i] = digit_map[char('0'+ i)];
    }
    
    vector<vector<int>> dist(n, vector<int>(n, INT_MAX));
    for(int i=0; i<n; i++){
        auto d = bfs(order[i]);
        for(int j=0; j<n; j++){
            dist[i][j] = d[order[j].first][order[j].second];
        }
    }
    
    int ans = findTSP(dist, n);
    
    cout << ans << endl;
    return 0;
}

--------------
Input:
5 5
.S*..
..*2.
.....
1..**
...3.

Output:
0 4 5 6 
4 0 5 4 
5 5 0 5 
6 4 5 0 
18

============================

Question4: Rental robot vacuum cleaner fee calculation

#include <iostream>
using namespace std;

char start_time[10];
char end_time[10];

void InputData(void)
{
	cin >> start_time;
	cin >> end_time;
}

int ConvertInt(char * t)
{
	return (t[0] - '0') * 10 + (t[1] - '0');
}

int ComputeTime(void)
{
	int s = ConvertInt(start_time) * 60 + ConvertInt(start_time + 3);
	int e = ConvertInt(end_time) * 60 + ConvertInt(end_time + 3);
	if(e<s) e += 24*60;

	return (e - s);
}

int Solve(void)
{
	int p;
	int t = ComputeTime();
	if (t < 30) return 500;
	t -= 30;
	p = 500 + ((t+9)/10) * 300;
	
	if(p>30000) return 30000;

	return p;
}

void OutputData(int sol)
{
	cout << sol;
}

int main(void)
{
	int sol = -1;
	InputData();// 입력

	sol = Solve();

	OutputData(sol);// 출력

	return 0;
}

Input: 
07:00
08:00

Output:
1400


==================================

Question5: Creation of a Park

#include <bits/stdc++.h>
using namespace std;
int N;
vector<string> grid;

int dfs(int r, int c, char ch){
	int cnt=1;
	int dr[] = {0, 0, 1, -1};
	int dc[] = {1, -1, 0, 0};
	for(int d=0; d<4; d++){
		int nr = r + dr[d];
		int nc = c + dc[d];
		if(nr<0 || nr>=N || nc<0 || nc>=N || grid[nr][nc] != ch) continue;
		grid[nr][nc] = 'A';
		cnt += dfs(nr, nc, ch);
	}
	return cnt;
}

int main(){
	cin >> N;
	grid.resize(N);
	for(int i=0; i<N; i++) cin >> grid[i];
	
	int rz=0, rc=0, gz=0, gc=0, bz=0, bc=0;
	
	for(int i=0; i<N; i++){
		for(int j=0; j<N; j++){
			if(grid[i][j] == 'R'){
				rz++;
				rc += dfs(i, j, 'R');
			} else if(grid[i][j] == 'G'){
				gz++;
				gc += dfs(i, j, 'G');
			} else if(grid[i][j] == 'B'){
				bz++;
				bc += dfs(i, j, 'B');
			}
		}
	}
	priority_queue<pair<pair<int,int>,char>> pq;
	pq.push({{rz,rc},'R'});
	pq.push({{gz,gc},'G'});
	pq.push({{bz,bc},'B'});
	auto result = pq.top();
	char ans = result.second;
	int areacnt = result.first.first;
 
	cout << ans << " " << areacnt << "\n";
	return 0;
}

Input:
5
RRRBB
GGBBB
BBGRR
BBGGR
BRRRR


Output:
R 2

===================================

Question6: Plannet Travel

#include <bits/stdc++.h>
using namespace std;

int N;
int W[100000 + 10];

void InputData(void) {
	cin >> N;
	for (int i = 0; i < N; i++) {
		cin >> W[i];
	}
}

int main(void) {
	int ans = -1;

	InputData();
	
	stack<int> st;
	ans=N-1;
	for(int i=0; i<N; i++){
		while(!st.empty() && W[st.top()] < W[i]){
			st.pop();
		}
		if(!st.empty()) {
			ans+=i-st.top()>1? 1:0;
			if(W[st.top()] == W[i] && i-st.top()>1) ans--;
		}
		st.push(i);
	}
	for(int i=N-1; i>=0; i--){
		while(!st.empty() && W[st.top()] < W[i]){
			st.pop();
		}
		if(!st.empty())
			ans+=st.top()-i>1? 1:0;
		st.push(i);
	}
	cout << ans << endl;

	return 0;
}

Input: 
6
6 3 3 4 5 2


Output:
7


=================================

Question7: Hopscotch:

int dr[8] = { -1, 1, 0, 0, 1, 1, -1, -1 };
int dc[8] = { 0, 0, -1, 1, -1, 1, -1, 1 };

void Touch(int r, int c) {
	int V;

	if (A[r][c] == 0) V = 1;
	else V = 0;
	A[r][c] = V;

	for (int k = 0; k < 8; k++) {
		int nr = r;
		int nc = c;
		int flag = 0;

		for (;;) {
			nr = nr + dr[k];
			nc = nc + dc[k];
			if (nr < 0 || nr >= H || nc < 0 || nc >= W) break;
			if (A[nr][nc] == V) {
				flag = 1;
				break;
			}
		}
		int bomb=0;
		if (flag == 1) {
			nr = r;
			nc = c;
			for (;;) {
				nr = nr + dr[k];
				nc = nc + dc[k];
				if (nr < 0 || nr >= H || nc < 0 || nc >= W) break;
				if (A[nr][nc] == V && bomb == 0) {
					break;
				}
				if(A[nr][nc] == 2) bomb = 1;
				A[nr][nc] = V;
			}
		}
	}
}

Input:
5 6
0 2 0 0 0 0
0 0 1 1 0 1
0 2 2 1 0 0
1 2 1 1 0 0
0 1 1 0 0 2
2
1 2
1 1


Output:
14

===================================

Question8: Running:

#include <bits/stdc++.h>
using namespace std;

int N;
long long T;
long long P[100000 + 10];
long long S[100000 + 10];
int group_first[100000 + 10];


void InputData() {
	cin >> N >> T;
	for (int i = 0; i < N; i++) {
		cin >> P[i] >> S[i];
	}
}

int main() {
	InputData();
	vector<pair<long long, int>> pos(N);
	for(int i=0; i<N; i++){
		pos[i].first = P[i]+ T * S[i];
		pos[i].second = i+1;
	}
	vector<int> player;
	long long maxp = pos[N-1].first;
	player.push_back(N);
	for(int i=N-2; i>=0; i--){
		if(pos[i].first < maxp){
			player.push_back(pos[i].second);
			maxp = pos[i].first;
		}
	}
	cout << player.size() << endl;
	for(auto p:player) cout << p << " ";
	return 0;
}

Input:
5 6
0 2
2 2
6 1
9 3
12 2

Output:
2
5 3 

=====================================

Question9: Collection of parcels

#include <bits/stdc++.h>
using namespace std;
#define pii pair<int, int>

vector<pii> pos;
long long distance(pii x, pii y){
    return (abs(x.first - y.first)+abs(x.second-y.second));
}

long long solveTSP(vector<int>&list, int ind){
    if(list.empty()) return 0;
    vector<int> loc = list;
    sort(loc.begin(), loc.end());
    long long min_cost=LLONG_MAX;
    do{
        long long cost=0;
        pii src = pos[ind];
        pii dest = pos[loc[0]];
        cost += distance(src, dest);
        for(int i=0; i<(int)loc.size()-1; i++){
            src = pos[loc[i]];
            dest = pos[loc[i+1]];
            cost += distance(src, dest) * (i+2);
        }
        cost += distance(pos[loc.back()], pos[ind]) * ((int)loc.size() + 1);
        min_cost = min(min_cost, cost);

    } while (next_permutation(loc.begin(), loc.end()));
    return min_cost;
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int N;
	cin >> N;
	pos.resize(N+2);
	for(int i=0; i<2; i++){
		cin >> pos[i+N].first >> pos[i+N].second;
	}
	for(int i=0; i<N; i++){
		cin >> pos[i].first >> pos[i].second;
	}
	long long ans = LLONG_MAX;
	int total = 1 << N;
	for(int mask=0; mask<total; mask++){
		vector<int> listA, listB;
		for(int i=0; i<N; i++){
			if(mask & (1<<i))
				listA.push_back(i);
			else
				listB.push_back(i);
		}
		/*
		for(auto x:listA) cout << x << " ";
		cout << endl;
		for(auto x:listB) cout << x << " ";
		cout << endl;*/
		long long costA = solveTSP(listA, N);
		long long costB = solveTSP(listB, N+1);
		ans = min(ans, costA+costB);
	}
	cout << ans <<  endl;
	return 0;
}

Input:
3
10 10
20 20
5 5
12 8
30 30

Output:
102

===================================

Question10: Finding hidden pictures


#include <iostream>
using namespace std;

int N;
int a[10 + 10][10 + 10];
int X1, X2, X3;

int di[8] = { -1,-1,0,1,1,1,0,-1 };
int dj[8] = { 0,1,1,1,0,-1,-1,-1 };
int Solve(void) {
	int count = 0;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (a[i][j] != X1) continue;
			for (int k = 0; k < 8; k++) {
				int ni = i + di[k];
				int nj = j + dj[k];
				if (ni < 0 || ni >= N) continue;
				if (nj < 0 || nj >= N) continue;
				if (a[ni][nj] != X2) continue;
				int nr = ni + di[k];
				int nc = nj + dj[k];
				if (nr < 0 || nr >= N) continue;
				if (nc < 0 || nc >= N) continue;
				if (a[nr][nc] != X3) continue;
				count++;
			}
		}
	}
	return count;
}

void InputData(void) {
	cin >> N;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cin >> a[i][j];
		}
	}
	cin >> X1 >> X2 >> X3;
}

int main(void) {
	int ans;
	InputData();
	ans = Solve();
	cout << ans;
	return 0;
}

==================================

Question11: Math Galaxy


#include <bits/stdc++.h>
using namespace std;

int S, E1, E2;
int ans1=INT_MAX, ans2 = INT_MAX;
vector<int> factors(10000);

void InputData()
{
	cin >> S >> E1 >> E2;
}

bool isDiffOne(int a,int b)
{
	int diffCount = 0;
    for (int i = 0; i < 4; ++i) {
        if (a % 10 != b % 10)
            diffCount++;
        a /= 10;
        b /= 10;
    }
    if(diffCount==1)
		return true;
	return false;
}
 
int main()
{
	InputData();// 입력받는 부분
	// 여기서부터 작성
	if(S==E1) ans1=0;
	if(S==E2) ans2=0;

	vector<vector<int>> adj(10000);
	for (int i = 1; i <= 9999; ++i) {
		for (int j = i; j <= 9999; j += i) {
			factors[j]++;
		}
	}

	for(int i=1000;i<=9999;i++)
	{
		for(int j=i+1;j<=9999;j++)
		{
			if(isDiffOne(i,j) && abs(factors[i]-factors[j])<=1)
			{
				//cout << i << " " << j << endl;
				adj[i].push_back(j);
				adj[j].push_back(i);
			}
		}
	}
	queue<pair<int,int>> q;
	vector<int> vis(10000,0);
	q.push({S,0});
	vis[S] = 1;
	while(!q.empty())
	{
		int u = q.front().first;
		int d = q.front().second;
		q.pop();
		for(auto v : adj[u])
		{
			if(!vis[v])
			{
				vis[v] = 1;
				q.push({v,d+1});
				if(v == E1)
					ans1 = min(ans1,d+1);
				if(v == E2)
					ans2 = min(ans2,d+1);
			}
		}
		if(ans1 != INT_MAX && ans2 != INT_MAX)
			break;
	}

	cout << ans1 << '\n';// 출력하는 부분
	cout << ans2 << '\n';
	return 0;
}


Input:
2023 2225 2123

Output:
3
8

-------------------------
int findNumberOfFactors(int i)
{
	int count=0;
	for(int k = 1; k * k <= i; ++k)
	{
		if(i%k==0)
			count+=2;
		if (k * k == i) count--;
	}
	return count;
}

===================================

Question12 : Removal of foreign particle:

#include <bits/stdc++.h>
using namespace std;

int N;
int K;
int X[50000];

void InputData() {
	cin >> N >> K;
	for (int i = 0; i < N; i++) {
		cin >> X[i];
	}
}
 
bool check(int mid) {
	int cnt=0;
	int cp=0;
	for(int i=0; i<N; i++){
		if(cp>=X[i])continue;
		else{
			cnt++;
			cp=X[i]+2 * mid;
		}
	}
	return cnt<=K;
}
 
int main() {
	int ans = 0;
	InputData();

	sort(X,X+N);
	int start=1;
	int end = X[N-1];
	//cout << end << " - " << start << endl;

	while(start <= end)
	{
		int mid = (end+start)/2;
		if(check(mid))
		{
			ans = mid;
			end = mid-1;
		}
		else
		{
			start = mid+1;
		}
	}
	cout << ans << endl;
	return 0;
}

Input:
7 2
20
25
18
8
10
3
1


Output:
5


==================================

Question13: Clockwise rotation:


#define SWAP(a, b) {int temp = a;a = b;b = temp;}
void Rotate(int sr, int sc, int er, int ec) {
	if(sr>=er || sc>=ec) return;
	int a = Mat[sr][sc];
	for (int r = sr + 1; r <= er; r++) {
		SWAP(Mat[r][sc], a);
	}
	for (int c = sc + 1; c <= ec; c++) {
		SWAP(Mat[er][c], a);
	}
	for (int r = er - 1; r >= sr; r--) {
		SWAP(Mat[r][ec], a);
	}
	for (int c = ec - 1; c >= sc; c--) {
		SWAP(Mat[sr][c], a);
	}
}

void Solve(void) {
	int n = R > C ? R : C;
	for (int i = 0; i < n; i++) {
		Rotate(0 + i, 0 + i, R - 1 - i, C - 1 - i);
	}
}

Input:
3 3
1 2 3
4 5 6
7 8 9

Output:
2 3 6
1 5 9
4 7 8

================================

Question14: Dividing an Area

#include <bits/stdc++.h>
using namespace std;
 
int dx[4]={1,-1,0,0};
int dy[4]={0,0,-1,1};
 
int main() {

	int N;
	string Info;
	cin >> N >> Info;
	set<pair<pair<int, int>, pair<int, int>>> visitedEdges;
	set<pair<int, int>> visitedPositions;
	int x = 0, y = 0;
	visitedPositions.insert({x, y});
	int loops = 0;
 
	for (int i = 0; i < N; ++i) {
		int dir = Info[i] - '0';
		int nx = x + dx[dir];
		int ny = y + dy[dir];
		pair<int, int> from = {x, y};
		pair<int, int> to = {nx, ny};
		if (visitedPositions.count(to) && visitedEdges.count({from, to}) == 0) {
			loops++;
		}
 
		visitedEdges.insert({from, to});
		visitedEdges.insert({to, from});
		visitedPositions.insert(to);
		x = nx;
		y = ny;
	}
 
	cout << loops << "\n";
	return 0;
}

Input:
14
33302111220000

Output:
2

==========================

Question15: Chemical Synthesis:

#include <bits/stdc++.h>
using namespace std;
#define MAXN ((int)2e5)
int N, M;
int ID[MAXN + 10];
 
void InputData(){
	cin >> N >> M;
	for (int i = 0; i < N; i++){
		cin >> ID[i];
	}
}
 
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
 
	int ans = 0;
	InputData();

	map<int,int> mp;
	for(int i=0;i<M;i++)
	{
		mp[ID[i]]++;
	}
	int left=0,right=M-1;
	while(right<N)
	{
		for(int k=0;k<=15;k++)
		{
			ans = max(ans,mp[k]+mp[k+1]+mp[k+2]);
		}
		mp[ID[left++]]--;
		mp[ID[++right]]++;
	}
 
	cout << ans << "\n";
	return 0;
}

Input:
10 8
7 15 3 3 7 8 7 15 3 3 


Output:
4
